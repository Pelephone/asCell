/** Copyright(c) 2011 the original author or authors.** Licensed under the Apache License, Version 2.0 (the "License");* you may not use this file except in compliance with the License.* You may obtain a copy of the License at**     http://www.apache.org/licenses/LICENSE-2.0** Unless required by applicable law or agreed to in writing, software* distributed under the License is distributed on an "AS IS" BASIS,* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,* either express or implied. See the License for the specific language* governing permissions and limitations under the License.*/package netSocket{	import flash.utils.ByteArray;	import flash.utils.Endian;	/**	 * 处理二进制数据工具	 * @author Michael.Huang	 *	 */	public class MessgeUtil	{		/**		 * 创建一个字节序为低位的 ByteArray		 */		public static function createByteArray(endian:String = Endian.LITTLE_ENDIAN):ByteArray		{			return new MsgByteArray(endian);		}		/** 将ByteArray转换成十六进制		 * @param ba:ByteArray	要输出的bytes		 * @param str:String		 * @param radix:String	进制		 * @return String		 *  */		public static function bytesToHex(ba:ByteArray, str:String = "Send ", radix:int = 16):String		{			var s:String = str + "(" + ba.length + " B)";			ba.position = 0;			var tmp:String = "";			while (ba && ba.bytesAvailable)			{				tmp = ("00" + ba.readUnsignedByte().toString(radix).toUpperCase());				s += (" " + tmp.slice(tmp.length - (256 / (radix * radix) + 1), tmp.length));			}			return s;		}		/**		 * writeUTF，向二进制数组中写入一个字符串，在结尾处加一个0做结束		 */		public static function writeUTF(ba:ByteArray, str:String):void		{			if (str == null)				str = "null";			ba.writeUTF(str);			// UTF类型结尾补0			ba.writeByte(0);		}		/**		 * 写入一个64位的数(只能用正数,负数不能用)		 */		public static function write64Int(ba:ByteArray, n:Number):void		{			var h:int = n / (65536 * 65536); // 高位			var l:int = n % (65536 * 65536); // 低位			if (ba.endian == Endian.LITTLE_ENDIAN)			{				ba.writeInt(l);				ba.writeInt(h);			}			else			{				ba.writeInt(h);				ba.writeInt(l);			}		}		/**		 * 读取一个64位的数		 */		public static function read64Int(ba:ByteArray):Number		{			var h:int = ba.readInt(); // 高位			var l:int = ba.readInt(); // 低位			var n:Number;			if (ba.endian == Endian.LITTLE_ENDIAN)				n = 65536 * 65536 * l + h;			else				n = 65536 * 65536 * h + l;			return n;		}		/**		 * 编码数据包，将数据流编码成定义好的数据包格式		 */		public static function encodeByteArray(ba:ByteArray):ByteArray		{			var res:ByteArray = MessgeUtil.createByteArray();			res.writeInt(ba.length);			res.writeBytes(ba, 0, ba.length);			return res;		}		/**		 * 添加定长的字符创到一个字节流中		 * @param str:String	要添加的字符串		 * @param len:int		要添加的长度		 * @return ByteArray		 */		public static function addCharsToBytes(str:String, len:int):ByteArray		{			var res:ByteArray = createByteArray();			res.length = len;			res.position = 0;			res.writeUTFBytes(str);			res.position = 0;			// 创建一个新数组，读取指定长度内容			var bytes:ByteArray = createByteArray();			res.readBytes(bytes, 0, len);			res = null;			return bytes;		}		/**		 * 根据字串长度读取字串		 * @param by:ByteArray	源字节流		 * @param len:int		长度		 * @return String		 */		public static function readCharsFromBytes(by:ByteArray, len:int):String		{			var res:String = "";			var tmpBy:ByteArray = MessgeUtil.createByteArray();			by.readBytes(tmpBy, 0, len);			res = tmpBy.readUTFBytes(len);			return res;		}	}}import flash.utils.ByteArray;/** * 构造函数中指定字节序 * @author Michael.Huang * */class MsgByteArray extends ByteArray{	public function MsgByteArray(endian:String)	{		super();		this.endian = endian;	}}