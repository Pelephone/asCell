/** Copyright(c) 2011 the original author or authors.** Licensed under the Apache License, Version 2.0 (the "License");* you may not use this file except in compliance with the License.* You may obtain a copy of the License at**     http://www.apache.org/licenses/LICENSE-2.0** Unless required by applicable law or agreed to in writing, software* distributed under the License is distributed on an "AS IS" BASIS,* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,* either express or implied. See the License for the specific language* governing permissions and limitations under the License.*/package netSocket{	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IOErrorEvent;	import flash.events.ProgressEvent;	import flash.events.SecurityErrorEvent;	import flash.net.Socket;	import flash.system.Security;	import flash.utils.ByteArray;	import flash.utils.getTimer;		import netSocket.interfaces.IConnection;	import netSocket.interfaces.IMessage;
	//	CONFIG::debug//	{//		import org.as3commons.logging.ILogger;//		import org.as3commons.logging.LoggerFactory;//	}
		/**	 * 连接失败事件	 */		[Event(name = "connFailure", type = "com.trueHero.game.common.events.SocketConnectionEvent")]	/**	 * 连接成功事件	 */		[Event(name = "connSuccess", type = "com.trueHero.game.common.events.SocketConnectionEvent")]		/**	 * 关闭连接成功事件	 */		[Event(name = "closeSuccess", type = "com.trueHero.game.common.events.SocketConnectionEvent")]		/**	 * 接收到协议消息事件	 */		[Event(name = "receiveMessage", type = "com.trueHero.game.common.events.SocketConnectionEvent")]	/**	 * @author Michael.Huang	 */	public class SocketConnection extends EventDispatcher implements IConnection	{//		CONFIG::debug//		{//			private static var logger:ILogger = LoggerFactory.getClassLogger(SocketConnection);//		}		public function SocketConnection()		{			super();			_buffer = new ByteArrayBuffer();		}		/**		 *		 * 服务器地址		 *		 */		private var _server:String;		/**		 *		 * 服务器端口		 *		 */		private var _port:int;		/**		 *		 * 通信socket		 *		 */		private var _socket:Socket;		/**		 *		 * 字节流缓冲池		 *		 */		private var _buffer:ByteArrayBuffer;		/**		 * 返回服务器信息		 * @return		 *		 */		public function get serverInfo():String		{			return " ( " + _server + "-" + _port + " ) ";		}		/**		 * 是否已经连接		 */		public function get connected():Boolean		{			return (_socket && _socket.connected);		}		/**		 *		 * 注册socket事件		 *		 */		protected function configEventListener():void		{			deleteEventListener(_socket);			if (_socket != null)			{				_socket.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);				_socket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);				_socket.addEventListener(Event.CLOSE, closeHandler);				_socket.addEventListener(Event.CONNECT, connectHandler);				_socket.addEventListener(ProgressEvent.SOCKET_DATA, socketDataHandler);			}		}		/**		 * 删除socket事件		 * @param socket		 *		 */		protected function deleteEventListener(socket:Socket):void		{			if (socket != null)			{				socket.removeEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);				socket.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);				socket.removeEventListener(Event.CLOSE, closeHandler);				socket.removeEventListener(Event.CONNECT, connectHandler);				socket.removeEventListener(ProgressEvent.SOCKET_DATA, socketDataHandler);			}		}		/**		 * 连接服务器		 * @param _server:String	服务器地址		 * @param _port:int			服务器端口		 * @param policyFilePort 安全策略端口		 * 		 */		public function connect(_server:String, _port:int, policyFilePort:int=8080):void		{			if (null == _socket)				_socket = new Socket();			this._server = _server;			this._port = _port;			//添加侦听器			configEventListener();			if (_socket.connected) //如果已经连接，先断开				_socket.close();//			CONFIG::debug//			{//				logger.debug("连接服务器 ... server- " + _server + "  port-" + _port, this);//			}			trace("连接服务器 ... server- " + _server + "  port-" + _port, this);			//安全策略			var policyFile:String = "xmlsocket://" + _server + ":" + policyFilePort;						//安全策略//			var policyFile:String = "xmlsocket://" + _server + ":" + _port;			Security.loadPolicyFile(policyFile);			//连接服务器			_socket.connect(_server, _port);		}		/**		 * 向服务器端发送数据		 * @param msg:IMessage	要发送的数据		 */		public function sendMsg(msg:IMessage):void		{			if (!connected)			{//				CONFIG::debug//				{//					logger.debug("sendMsg : 连接服务器断开", _server, _port, this);//				}				trace("sendMsg : 连接服务器断开", _server, _port, this);				dispathFaildEvent(SocketConnectionEvent.CLOSE_ERROR);				return;			}			var ba:ByteArray = MessgeUtil.encodeByteArray(msg.msgData);			ba.position = 0;			_socket.writeBytes(ba, 0, ba.length);			_socket.flush();		}		/**		 * 关闭服务器连接		 */		public function close():void		{			if (connected)				_socket.close();			var e:SocketConnectionEvent = new SocketConnectionEvent(SocketConnectionEvent.CLOSE_SUCCESS);			dispatchEvent(e);		}		//--------------------------------------------------------		//		// Event handlers		//		//--------------------------------------------------------		/**		 *		 * @private		 *		 */		private function ioErrorHandler(event:IOErrorEvent):void		{//			CONFIG::debug//			{//				logger.debug("  ioError:连接服务器失败" + serverInfo, this);//			}			trace("  ioError:连接服务器失败" + serverInfo, this);			dispathFaildEvent(SocketConnectionEvent.IO_ERROR);		}		/**		 *		 * @private		 *		 */		private function securityErrorHandler(event:SecurityErrorEvent):void		{//			CONFIG::debug//			{//				logger.debug("  SecurityError:连接服务器失败" + serverInfo, this);//			}			trace("  SecurityError:连接服务器失败" + serverInfo, this);			dispathFaildEvent(SocketConnectionEvent.SECURITY_ERROR);		}		/**		 *		 * @private		 *		 */		private function closeHandler(event:Event):void		{//			CONFIG::debug//			{//				logger.debug("  close:连接关闭" + serverInfo, this);//			}			trace("  close:连接关闭" + serverInfo, this);			dispathFaildEvent(SocketConnectionEvent.CLOSE_ERROR);		}		/**		 *		 * @private		 *		 */		private function connectHandler(event:Event):void		{//			CONFIG::debug//			{//				logger.debug("  连接服务器成功！！！！！！！" + serverInfo, this);//			}			trace("  连接服务器成功！！！！！！！" + serverInfo, this);			var e:SocketConnectionEvent = new SocketConnectionEvent(SocketConnectionEvent.CONN_SUCCESS);			dispatchEvent(e);		}		/**		 *		 * 接收到字节流数据，先放到缓冲池，再调用分包方法分包，然后再讲每个包都分发出去		 *		 */		private function socketDataHandler(event:ProgressEvent):void		{			var byteArray:ByteArray = MessgeUtil.createByteArray();			_socket.readBytes(byteArray, 0, event.bytesLoaded);			//讲读取到的数据加入缓冲池			_buffer.cacheBytes(byteArray);			//触发缓冲池的拆分包方法，讲字节流拆分成一个个的包			var packages:Array = _buffer.splitBufferToPackage();			for (var i:int = 0; i < packages.length; i++)				receiveMsg(packages[i]);		}		/**		 *		 * 将接收到的字节流数据转发出去		 *		 */		private function receiveMsg(bytes:ByteArray):void		{			if (bytes == null)				return;			var event:SocketConnectionEvent = new SocketConnectionEvent(SocketConnectionEvent.RECEIVE_MESSAGE);			event.msgData = new MessageData(bytes);			event.timestamp = flash.utils.getTimer();			dispatchEvent(event);		}		/**		 *		 * 发布失败事件		 * @param type:String   失败的类型		 *		 */		public function dispathFaildEvent(type:String):void		{			var event:SocketConnectionEvent = new SocketConnectionEvent(SocketConnectionEvent.CONN_FAILURE);			event.faildType = type;			dispatchEvent(event);		}	}}