/** Copyright(c) 2011 the original author or authors.** Licensed under the Apache License, Version 2.0 (the "License");* you may not use this file except in compliance with the License.* You may obtain a copy of the License at**     http://www.apache.org/licenses/LICENSE-2.0** Unless required by applicable law or agreed to in writing, software* distributed under the License is distributed on an "AS IS" BASIS,* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,* either express or implied. See the License for the specific language* governing permissions and limitations under the License.*/package netSocket{	import flash.utils.ByteArray;	/**	 * 服务器端返回的字节流缓冲池	 * @author Michael.Huang	 */	public class ByteArrayBuffer	{		public function ByteArrayBuffer()		{			_buffer = MessgeUtil.createByteArray();		}		private var _buffer:ByteArray;		/**		 * 可读取的字节数		 */		public function get bytesAvailable():uint		{			return _buffer == null ? 0 : _buffer.length;		}		/**		 * 将收到的字节流缓存到缓冲区		 * @param byteArray:ByteArray	缓冲的字节流		 * @return		 */		public function cacheBytes(byteArray:ByteArray):void		{			byteArray.position = 0;			_buffer.position = 0;			if (_buffer.length > 0)			{				_buffer.position = _buffer.length;			}			_buffer.writeBytes(byteArray, 0, byteArray.length);			try			{				byteArray.clear();			}			catch (e:Error)			{				// do nothing			}		}		/**		 * 将字节流分解成数据包		 * @return Array	解出来的数据包数组		 */		public function splitBufferToPackage():Array		{			var res:Array = [];			if (_buffer == null)				return res;			//从第一个字节开始读起			_buffer.position = 0;			//开始读取缓冲池			if (_buffer.bytesAvailable > 0)			{				//循环读取里面的包				while (true)				{					if (_buffer.bytesAvailable < 4)						break;					var len:int = _buffer.readInt(); //包的长度					var totLen:int = _buffer.bytesAvailable; //剩余的总的长度					if (totLen >= len)					{						var ba:ByteArray = MessgeUtil.createByteArray();						_buffer.readBytes(ba, 0, len);						res.push(ba);					}					else					{						//读取包长的时候，指针已经移动了，所以移回去						if (_buffer.position >= 4)							_buffer.position -= 4;						break;					}				}				//清空缓冲池中已经被读取的包的数据				var leftbytes:uint = _buffer.bytesAvailable;				if (leftbytes > 0)				{					//缓冲池中还有数据没有读取，则保留在缓冲池中，直到下次服务器端数据到达之后，触发读取					var tmp:ByteArray = MessgeUtil.createByteArray();					_buffer.readBytes(tmp, 0, leftbytes);					//清除缓冲区的字节					try					{						_buffer.clear();					}					catch (e:Error)					{						// do nothing					}					//将剩下的重新放回缓冲池					_buffer = tmp;					_buffer.position = 0;				}				else				{					//_buffer是空的了------					//清楚缓冲区的字节-----					try					{						_buffer.clear();					}					catch (e:Error)					{						// do nothing					}					_buffer = MessgeUtil.createByteArray();					_buffer.position = 0;				}			}			return res;		}	}}